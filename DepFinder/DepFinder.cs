using DepFinder.Services;
using DepFinder.Entities;
using DepFinder.Interfaces;
using Microsoft.Extensions.DependencyInjection;

namespace DepFinder;

/// <summary>
/// Static factory class for easy DepFinder usage without DI setup
/// </summary>
public static class DepFinder
{
    /// <summary>
    /// Creates a new DepFinder instance with all dependencies configured
    /// </summary>
    /// <returns>Ready-to-use DepFinderService instance</returns>
    public static DepFinderService Create()
    {
        var services = new ServiceCollection();
        services.AddDepFinder();
        
        var serviceProvider = services.BuildServiceProvider();
        return new DepFinderService(serviceProvider);
    }

    /// <summary>
    /// Generates a stub class with NSubstitute mocks for all dependencies
    /// </summary>
    /// <param name="sourceClassType">The source class type to analyze</param>
    /// <param name="stubClassName">The name for the generated stub class</param>
    /// <returns>The generated stub class content</returns>
    public static async Task<string> GenerateStubClassAsync(Type sourceClassType, string stubClassName)
    {
        using var service = Create();
        return await service.GenerateStubClassAsync(sourceClassType, stubClassName);
    }

    /// <summary>
    /// Generates a stub class and saves it to the specified directory
    /// </summary>
    /// <param name="sourceClassType">The source class type to analyze</param>
    /// <param name="outputDirectory">Directory where the stub file will be saved</param>
    /// <returns>The path of the saved file</returns>
    public static async Task<string> GenerateAndSaveStubAsync(Type sourceClassType, string outputDirectory)
    {
        using var service = Create();
        return await service.GenerateAndSaveStubAsync(sourceClassType, outputDirectory);
    }

    /// <summary>
    /// Generates a SUT factory class that creates the system under test with stub dependencies
    /// </summary>
    /// <param name="sourceClassType">The source class type to analyze</param>
    /// <param name="stubClassName">The name of the stub class generated by GenerateStubClassAsync</param>
    /// <param name="stubFilePath">The file path of the stub class generated by GenerateAndSaveStubAsync</param>
    /// <param name="outputDirectory">Directory where the SUT factory file will be saved</param>
    /// <returns>The path of the saved SUT factory file</returns>
    public static async Task<string> GenerateSutFactoryClassAsync(Type sourceClassType, string stubClassName, string stubFilePath, string outputDirectory)
    {
        using var service = Create();
        return await service.GenerateSutFactoryClassAsync(sourceClassType, stubClassName, stubFilePath, outputDirectory);
    }

    /// <summary>
    /// Analyzes the architecture for a specific class/controller and returns a structured representation
    /// </summary>
    /// <param name="targetClass">The class/controller to analyze</param>
    /// <returns>Complete architectural flow information</returns>
    public static async Task<ArchitecturalFlow> AnalyzeArchitectureAsync(Type targetClass)
    {
        using var service = Create();
        return await service.AnalyzeArchitectureAsync(targetClass);
    }

    /// <summary>
    /// Generates a visual ASCII diagram of the architecture for a specific class/controller
    /// </summary>
    /// <param name="targetClass">The class/controller to analyze</param>
    /// <returns>ASCII art representation of the architecture</returns>
    public static async Task<string> GenerateArchitecturalDiagramAsync(Type targetClass)
    {
        using var service = Create();
        return await service.GenerateArchitecturalDiagramAsync(targetClass);
    }

    /// <summary>
    /// Generates and saves an architectural diagram to a file for a specific class/controller
    /// </summary>
    /// <param name="targetClass">The class/controller to analyze</param>
    /// <param name="outputPath">Path where the diagram file should be saved</param>
    /// <returns>Path to the saved diagram file</returns>
    public static async Task<string> GenerateAndSaveArchitecturalDiagramAsync(Type targetClass, string outputPath)
    {
        using var service = Create();
        return await service.GenerateAndSaveArchitecturalDiagramAsync(targetClass, outputPath);
    }
}

/// <summary>
/// Extension methods for easy DI registration
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds all DepFinder services to the dependency injection container
    /// </summary>
    /// <param name="services">The service collection</param>
    /// <returns>The service collection for chaining</returns>
    public static IServiceCollection AddDepFinder(this IServiceCollection services)
    {
        services.AddScoped<IDependencyAnalyzer, DependencyAnalyzer>();
        services.AddScoped<IStubGenerator, StubGenerator>();
        services.AddScoped<IFileService, FileService>();
        services.AddScoped<IPackageManager, PackageManager>();
        services.AddScoped<IArchitecturalAnalyzer, ArchitecturalAnalyzer>();
        services.AddScoped<DependencyAnalysisService>();
        services.AddScoped<PackageInstallationService>();
        services.AddScoped<DepFinderService>();
        
        return services;
    }
}